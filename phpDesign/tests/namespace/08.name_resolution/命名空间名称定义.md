##命名空间名称定义
####非限定名称(Unqualified name)
>名称中不包含命名空间分隔符的标识符，例如 Foo

####限定名称Qualified name
>名称中含有命名空间分隔符的标识符，例如 Foo\Bar

####完全限定名称Fully qualified name
>名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \Foo\Bar。 namespace\Foo 也是一个完全限定名称。

##名称解析遵循下列规则：

1.  对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。
2.  所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。
3.  在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。
4.  非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。
5.  在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：
6.  在当前命名空间中查找名为 A\B\foo() 的函数
7.  尝试查找并调用 全局(global) 空间中的函数 foo()。
8.  在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程：
    > new C()的解析:
      1. 在当前命名空间中查找A\B\C类。
      2. 尝试自动装载类A\B\C。
    > new D\E()的解析:
    1.   在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。
    2.   尝试自动装载类 A\B\D\E。

​    为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。